# Simple Go-Back-N Sliding Window Protocol

WINDOW = 4               # window size
TOTAL = 10              # total packets to send

sender_base = 0
next_seq = 0
receiver_expected = 0

print("\n--- Go Back N Sliding Window Simulation ---\n")

while sender_base < TOTAL:
    
    # Sender: send packets within window
    while next_seq < sender_base + WINDOW and next_seq < TOTAL:
        print(f"SENDER: Sent Packet {next_seq}")
        next_seq += 1

    # Receiver: receives the next expected packet
    print(f"RECEIVER: Received Packet {receiver_expected} -> ACK {receiver_expected}")
    
    # Sender gets ACK and slides window
    sender_base = receiver_expected + 1
    receiver_expected += 1
    print(f"SENDER: Window slides, new base = {sender_base}\n")

print("\nAll packets sent and acknowledged successfully!")


//1

# Distance Vector Routing (Short Version)

INF = 10**9

graph = {
    'A': {'B': 2, 'C': 5},
    'B': {'A': 2, 'C': 1, 'D': 2},
    'C': {'A': 5, 'B': 1, 'D': 3, 'E': 1},
    'D': {'B': 2, 'C': 3, 'E': 2},
    'E': {'C': 1, 'D': 2}
}

nodes = list(graph.keys())

# Initialize routing tables
dist = {n: {d: INF for d in nodes} for n in nodes}
nxt  = {n: {d: None for d in nodes} for n in nodes}

for n in nodes:
    dist[n][n] = 0
    nxt[n][n] = n
    for nb, w in graph[n].items():
        dist[n][nb] = w
        nxt[n][nb] = nb

# Distance Vector Algorithm
changed = True
while changed:
    changed = False
    for u in nodes:
        for v, w in graph[u].items():
            for d in nodes:
                if dist[u][d] > w + dist[v][d]:
                    dist[u][d] = w + dist[v][d]
                    nxt[u][d] = v
                    changed = True

# Print routing tables
for n in nodes:
    print(f"\nRouting table of {n}:")
    print("Dest | Cost | NextHop")
    for d in nodes:
        print(f"  {d}   |  {dist[n][d]}   |   {nxt[n][d]}")

//
# Simple Broadcast Tree using BFS

from collections import deque

# Example subnet of hosts
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B'],
    'F': ['C']
}

def broadcast_tree(graph, root):
    parent = {root: None}      # root has no parent
    q = deque([root])

    while q:
        u = q.popleft()
        for v in graph[u]:
            if v not in parent:     # not visited yet
                parent[v] = u       # tree edge
                q.append(v)
    return parent

# Build tree
root = 'A'
tree = broadcast_tree(graph, root)

# Print Broadcast Tree
print("Broadcast Tree (Child <- Parent):")
for node, p in tree.items():
    print(f"{node} <- {p}")

//
Wireshark 
i. Packet Capture Using Wire shark  
ii. Starting Wire shark  
iii. Viewing Captured Traffic  
iv. Analysis and Statistics & Filters. 
 
i. Packet Capture Using Wireshark 
Wireshark is a network packet analyzer used to capture live traffic on a computer network. 
● Launch Wireshark and identify active network interfaces such as Ethernet or Wi
Fi from the home screen. 
● Select the interface showing live traffic and click Start Capturing Packets (icon of a 
blue shark fin) or press Ctrl + E to begin capture. 
● Wireshark collects frames and displays them in real time as a list in the Packet List 
Pane. 
ii. Starting Wireshark 
● Open Wireshark via Start Menu or Terminal. 
● Choose your network interface card (NIC) that carries internet traffic (for example, Wi
Fi 3 or eth0). 
● Click on Capture → Start, or use the keyboard shortcut Ctrl + E to begin recording 
packets. 
● Let it run briefly and then click Capture → Stop to finish. 
● Save your capture as .pcap file for further analysis. 
 
iii. Viewing Captured Traffic 
The Wireshark main window has three panes for inspecting packets: 
1. Packet List Pane – Displays each captured packet with details such as number, time, 
source, destination, protocol, and length. 
2. Packet Details Pane – Shows the hierarchical structure of selected packet protocols 
(Ethernet, IP, TCP, HTTP, etc.). 
 
 
3. Packet Bytes Pane – Displays raw data (in hexadecimal or ASCII) of the selected packet 
for low-level analysis. 
Clicking on any packet updates the other panes instantly, providing detail down to field-level 
structure in network headers. 
iv. Analysis and Statistics & Filters 
Wireshark provides analytical tools and filtering options for traffic examination: 
● Display Filters limit visible packets using syntax like ip.addr == 192.168.1.5, http, 
or tcp.port == 80. 
● Statistics Menu includes features: 
● Protocol Hierarchy: shows proportion of Ethernet, IP, TCP, and application
layer traffic. 
● Conversations: lists communication pairs between devices. 
● IO Graphs: visualizes traffic volume over time. 
● Follow TCP Stream reconstructs full client-server communication for one session. 
● Expert Info highlights retransmissions, delays, or malformed packets.
